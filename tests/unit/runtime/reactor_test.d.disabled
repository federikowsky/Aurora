/**
 * Reactor (Event Loop) Tests
 *
 * TDD: Aurora Reactor event loop wrapper
 *
 * Features:
 * - Reactor lifecycle (create, destroy, run, stop)
 * - Timer support (create, cancel, fire)
 * - Event loop integration
 * - Concurrency (multiple reactors)
 * - Error handling
 *
 * M2 Simplified: Timer-focused, socket registration deferred to Connection Management
 */
module tests.unit.runtime.reactor_test;

import unit_threaded;
import aurora.runtime.reactor;
import core.thread;
import core.time;
import core.atomic;

// ========================================
// LIFECYCLE TESTS
// ========================================

// Test 1: Create reactor → initialized
@("create reactor initialized")
unittest
{
    auto reactor = new Reactor();
    reactor.shouldNotEqual(null);
    reactor.destroy();
}

// Test 2: Destroy reactor → cleanup complete
@("destroy reactor cleanup")
unittest
{
    auto reactor = new Reactor();
    reactor.destroy();
    // Should not crash
}

// Test 3: Run reactor → processes events
@("run reactor processes events")
unittest
{
    auto reactor = new Reactor();
    shared bool timerFired = false;

    reactor.createTimer(10.msecs, () {
        atomicStore(timerFired, true);
        reactor.stop();
    });

    reactor.run();

    atomicLoad(timerFired).shouldEqual(true);
    reactor.destroy();
}

// Test 4: Stop reactor → exits cleanly
@("stop reactor exits cleanly")
unittest
{
    auto reactor = new Reactor();

    // Start reactor in background thread
    auto t = new Thread({
        reactor.run();
    });
    t.start();

    Thread.sleep(10.msecs);

    reactor.stop();
    t.join();

    reactor.destroy();
}

// Test 5: Run reactor after stop → no-op
@("run after stop is noop")
unittest
{
    auto reactor = new Reactor();

    reactor.stop();
    reactor.runOnce(1.msecs);  // Should be no-op

    reactor.destroy();
}

// ========================================
// TIMER TESTS
// ========================================

// Test 6: Create timer → fires after delay
@("timer fires after delay")
unittest
{
    auto reactor = new Reactor();
    shared bool fired = false;

    reactor.createTimer(20.msecs, () {
        atomicStore(fired, true);
    });

    // Run reactor for enough time
    foreach (_; 0..5)
    {
        reactor.runOnce(10.msecs);
    }

    atomicLoad(fired).shouldEqual(true);
    reactor.destroy();
}

// Test 7: Timer with 0ms delay → fires immediately
@("timer zero delay fires immediately")
unittest
{
    auto reactor = new Reactor();
    shared bool fired = false;

    reactor.createTimer(0.msecs, () {
        atomicStore(fired, true);
    });

    reactor.runOnce(1.msecs);

    atomicLoad(fired).shouldEqual(true);
    reactor.destroy();
}

// Test 8: Timer with 1s delay → fires after ~1s
@("timer one second delay")
unittest
{
    import std.datetime.stopwatch;

    auto reactor = new Reactor();
    shared bool fired = false;

    auto sw = StopWatch(AutoStart.yes);

    reactor.createTimer(100.msecs, () {
        atomicStore(fired, true);
        reactor.stop();
    });

    reactor.run();

    sw.stop();

    atomicLoad(fired).shouldEqual(true);
    auto elapsed = sw.peek().total!"msecs";
    elapsed.shouldBeGreaterThanOrEqualTo(90);  // At least 90ms
    elapsed.shouldBeLessThan(200);              // But less than 200ms

    reactor.destroy();
}

// Test 9: Cancel timer before firing → callback not called
@("cancel timer before firing")
unittest
{
    auto reactor = new Reactor();
    shared bool fired = false;

    auto timerId = reactor.createTimer(50.msecs, () {
        atomicStore(fired, true);
    });

    reactor.cancelTimer(timerId);

    // Run reactor past the timer delay
    foreach (_; 0..10)
    {
        reactor.runOnce(10.msecs);
    }

    atomicLoad(fired).shouldEqual(false);
    reactor.destroy();
}

// Test 10: Cancel timer after firing → no error
@("cancel timer after firing no error")
unittest
{
    auto reactor = new Reactor();
    shared TimerID firedTimerId;

    auto timerId = reactor.createTimer(10.msecs, () {
        atomicStore(firedTimerId, timerId);
    });

    foreach (_; 0..5)
    {
        reactor.runOnce(10.msecs);
    }

    // Cancel after it fired (should be safe)
    reactor.cancelTimer(timerId);

    reactor.destroy();
}

// Test 11: Multiple timers → all fire
@("multiple timers all fire")
unittest
{
    auto reactor = new Reactor();
    shared int firedCount = 0;

    foreach (i; 0..5)
    {
        reactor.createTimer((10 + i * 5).msecs, () {
            atomicOp!"+="(firedCount, 1);
        });
    }

    // Run reactor for enough time
    foreach (_; 0..10)
    {
        reactor.runOnce(10.msecs);
    }

    atomicLoad(firedCount).shouldEqual(5);
    reactor.destroy();
}

// Test 12: Timer accuracy → within tolerance
@("timer accuracy within tolerance")
unittest
{
    import std.datetime.stopwatch;

    auto reactor = new Reactor();
    shared bool fired = false;

    auto sw = StopWatch(AutoStart.yes);

    reactor.createTimer(100.msecs, () {
        atomicStore(fired, true);
        reactor.stop();
    });

    reactor.run();

    sw.stop();

    auto elapsed = sw.peek().total!"msecs";

    // Should fire within 100ms ± 20ms tolerance
    elapsed.shouldBeGreaterThanOrEqualTo(90);
    elapsed.shouldBeLessThan(120);

    reactor.destroy();
}

// Test 13: Recurring timer → fires multiple times
@("recurring timer fires multiple times")
unittest
{
    auto reactor = new Reactor();
    shared int fireCount = 0;

    TimerID timerId;
    void timerCallback()
    {
        int count = atomicOp!"+="(fireCount, 1);
        if (count < 3)
        {
            // Re-create timer for next iteration (simulating recurring)
            timerId = reactor.createTimer(10.msecs, &timerCallback);
        }
        else
        {
            reactor.stop();
        }
    }

    timerId = reactor.createTimer(10.msecs, &timerCallback);

    reactor.run();

    atomicLoad(fireCount).shouldEqual(3);
    reactor.destroy();
}

// Test 14: Timer with destroyed reactor → no crash
@("timer with destroyed reactor safe")
unittest
{
    auto reactor = new Reactor();

    reactor.createTimer(1000.msecs, () {
        // This should never fire because reactor is destroyed
    });

    reactor.destroy();
    // Should not crash
}

// Test 15: Create 100 timers → all fire
@("hundred timers all fire")
unittest
{
    auto reactor = new Reactor();
    shared int firedCount = 0;

    foreach (i; 0..100)
    {
        reactor.createTimer((10 + (i % 10)).msecs, () {
            atomicOp!"+="(firedCount, 1);
        });
    }

    // Run reactor for enough time
    foreach (_; 0..20)
    {
        reactor.runOnce(10.msecs);
    }

    atomicLoad(firedCount).shouldEqual(100);
    reactor.destroy();
}

// ========================================
// EVENT LOOP TESTS
// ========================================

// Test 16: runOnce() → processes single iteration
@("runOnce processes single iteration")
unittest
{
    auto reactor = new Reactor();

    reactor.runOnce(1.msecs);
    // Should complete without hanging

    reactor.destroy();
}

// Test 17: run() → blocks until stop()
@("run blocks until stop")
unittest
{
    auto reactor = new Reactor();
    shared bool running = false;

    auto t = new Thread({
        atomicStore(running, true);
        reactor.run();
        atomicStore(running, false);
    });

    t.start();

    Thread.sleep(20.msecs);
    atomicLoad(running).shouldEqual(true);

    reactor.stop();
    t.join();

    atomicLoad(running).shouldEqual(false);
    reactor.destroy();
}

// Test 18: stop() from callback → exits cleanly
@("stop from callback exits cleanly")
unittest
{
    auto reactor = new Reactor();

    reactor.createTimer(10.msecs, () {
        reactor.stop();
    });

    reactor.run();

    reactor.destroy();
}

// Test 19: Empty reactor run → returns quickly
@("empty reactor run returns quickly")
unittest
{
    import std.datetime.stopwatch;

    auto reactor = new Reactor();

    auto sw = StopWatch(AutoStart.yes);
    reactor.runOnce(1.msecs);
    sw.stop();

    auto elapsed = sw.peek().total!"msecs";
    elapsed.shouldBeLessThan(10);  // Should return quickly

    reactor.destroy();
}

// Test 20: Reactor runOnce performance → < 1ms
@("runOnce performance under 1ms")
unittest
{
    import std.datetime.stopwatch;

    auto reactor = new Reactor();

    auto sw = StopWatch(AutoStart.yes);
    reactor.runOnce(0.msecs);  // No timeout
    sw.stop();

    auto elapsed = sw.peek().total!"usecs";
    elapsed.shouldBeLessThan(1000);  // < 1ms = 1000μs

    reactor.destroy();
}

// ========================================
// CONCURRENCY TESTS
// ========================================

// Test 21: Multiple reactors → isolated
@("multiple reactors isolated")
unittest
{
    auto reactor1 = new Reactor();
    auto reactor2 = new Reactor();

    reactor1.shouldNotEqual(reactor2);

    reactor1.destroy();
    reactor2.destroy();
}

// Test 22: Reactor per worker thread → no interference
@("reactor per thread no interference")
unittest
{
    shared int fired1 = 0;
    shared int fired2 = 0;

    auto t1 = new Thread({
        auto reactor = new Reactor();
        reactor.createTimer(10.msecs, () {
            atomicOp!"+="(fired1, 1);
            reactor.stop();
        });
        reactor.run();
        reactor.destroy();
    });

    auto t2 = new Thread({
        auto reactor = new Reactor();
        reactor.createTimer(10.msecs, () {
            atomicOp!"+="(fired2, 1);
            reactor.stop();
        });
        reactor.run();
        reactor.destroy();
    });

    t1.start();
    t2.start();

    t1.join();
    t2.join();

    atomicLoad(fired1).shouldEqual(1);
    atomicLoad(fired2).shouldEqual(1);
}

// Test 23: Stop reactor from different thread → thread-safe
@("stop from different thread thread safe")
unittest
{
    auto reactor = new Reactor();

    auto t = new Thread({
        reactor.run();
    });

    t.start();

    Thread.sleep(10.msecs);

    // Stop from main thread
    reactor.stop();

    t.join();
    reactor.destroy();
}

// ========================================
// ERROR HANDLING TESTS
// ========================================

// Test 24: Invalid timer ID cancel → handled
@("invalid timer cancel handled")
unittest
{
    auto reactor = new Reactor();

    // Cancel invalid timer ID (should not crash)
    reactor.cancelTimer(TimerID(9999));

    reactor.destroy();
}

// Test 25: Reactor double-destroy → safe
@("reactor double destroy safe")
unittest
{
    auto reactor = new Reactor();

    reactor.destroy();
    reactor.destroy();  // Should be safe
}

// ========================================
// SOCKET API TESTS (Phase 0)
// ========================================

// Test 26: SocketEvent enum exists
@("SocketEvent enum exists")
unittest
{
    // Verify SocketEvent enum is available
    SocketEvent readEvent = SocketEvent.READ;
    SocketEvent writeEvent = SocketEvent.WRITE;

    readEvent.shouldEqual(SocketEvent.READ);
    writeEvent.shouldEqual(SocketEvent.WRITE);
}

// Test 27: SocketFD type alias exists
@("SocketFD type alias exists")
unittest
{
    // Verify SocketFD type is available
    SocketFD invalidSocket = SocketFD.invalid;
    invalidSocket.shouldEqual(SocketFD.invalid);
}

// Test 28: registerSocket accepts valid parameters
@("registerSocket accepts parameters")
unittest
{
    auto reactor = new Reactor();

    shared bool callbackFired = false;

    // Register with invalid socket (should not crash)
    reactor.registerSocket(SocketFD.invalid, SocketEvent.READ, () @safe nothrow {
        atomicStore(callbackFired, true);
    });

    // Should not crash
    reactor.destroy();
}

// Test 29: unregisterSocket handles invalid socket
@("unregisterSocket handles invalid socket")
unittest
{
    auto reactor = new Reactor();

    // Unregister invalid socket (should not crash)
    reactor.unregisterSocket(SocketFD.invalid);

    reactor.destroy();
}

// Test 30: Socket API methods are callable
@("socket API methods callable")
unittest
{
    auto reactor = new Reactor();

    shared int callCount = 0;

    auto callback = () @safe nothrow {
        atomicStore(callCount, atomicLoad(callCount) + 1);
    };

    // Test that we can call socket API methods without crashing
    reactor.registerSocket(SocketFD.invalid, SocketEvent.READ, callback);
    reactor.registerSocket(SocketFD.invalid, SocketEvent.WRITE, callback);
    reactor.unregisterSocket(SocketFD.invalid);

    // All methods should execute without throwing
    reactor.destroy();
}

// ========================================
// CRITICAL STRESS TESTS (Production)
// ========================================

// Test 31: 1K concurrent timers stress
@("1K concurrent timers")
unittest
{
    import std.datetime.stopwatch;
    
    auto reactor = new Reactor();
    shared int firedCount = 0;
    
    auto sw = StopWatch(AutoStart.yes);
    
    // Create 1000 timers with varying delays
    foreach (i; 0..1000)
    {
        auto delay = (10 + (i % 100)).msecs;
        reactor.createTimer(delay, () {
            atomicOp!"+="(firedCount, 1);
        });
    }
    
    // Run reactor until all timers fire
    foreach (_; 0..150)  // 150 iterations * 10ms = 1.5s max
    {
        reactor.runOnce(10.msecs);
        if (atomicLoad(firedCount) == 1000)
            break;
    }
    
    sw.stop();
    
    // All 1000 timers should have fired
    atomicLoad(firedCount).shouldEqual(1000);
    
    // Should complete in reasonable time (< 2 seconds)
    assert(sw.peek().total!"seconds" < 2, "1K timers stress too slow");
    
    reactor.destroy();
}

// Test 32: 10K concurrent timers extreme stress
@("10K concurrent timers extreme")
unittest
{
    import std.datetime.stopwatch;
    
    auto reactor = new Reactor();
    shared int firedCount = 0;
    
    auto sw = StopWatch(AutoStart.yes);
    
    // Create 10,000 timers with varying delays
    foreach (i; 0..10_000)
    {
        auto delay = (10 + (i % 200)).msecs;
        reactor.createTimer(delay, () {
            atomicOp!"+="(firedCount, 1);
        });
    }
    
    // Run reactor until all timers fire
    foreach (_; 0..300)  // 300 iterations * 10ms = 3s max
    {
        reactor.runOnce(10.msecs);
        if (atomicLoad(firedCount) == 10_000)
            break;
    }
    
    sw.stop();
    
    // All 10,000 timers should have fired
    atomicLoad(firedCount).shouldEqual(10_000);
    
    // Should complete in reasonable time (< 5 seconds)
    assert(sw.peek().total!"seconds" < 5, "10K timers stress too slow");
    
    reactor.destroy();
}

// Test 33: Timer precision under load
@("timer precision under load")
unittest
{
    import std.datetime.stopwatch;
    import std.algorithm : map, sum;
    import std.array : array;
    
    auto reactor = new Reactor();
    
    // Track actual fire times
    shared long[100] fireTimes;
    shared int fireIndex = 0;
    
    auto startTime = MonoTime.currTime;
    
    // Create 100 timers with 100ms delay
    foreach (i; 0..100)
    {
        reactor.createTimer(100.msecs, () {
            auto elapsed = MonoTime.currTime - startTime;
            int idx = atomicOp!"+="(fireIndex, 1) - 1;
            if (idx < 100)
            {
                atomicStore(fireTimes[idx], elapsed.total!"msecs");
            }
        });
    }
    
    // Run reactor
    foreach (_; 0..200)
    {
        reactor.runOnce(10.msecs);
        if (atomicLoad(fireIndex) >= 100)
            break;
    }
    
    // Calculate precision: all should fire around 100ms ± 30ms
    int preciseCount = 0;
    foreach (i; 0..100)
    {
        auto fireTime = atomicLoad(fireTimes[i]);
        if (fireTime >= 70 && fireTime <= 130)
            preciseCount++;
    }
    
    // At least 90% should be within ±30ms tolerance
    assert(preciseCount >= 90, "Timer precision too low under load");
    
    reactor.destroy();
}
